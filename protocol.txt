PROTOCOL

This file contains notes on what has been done and what needs to be done. It also 
holds important things to remember.

OPEN TASKS

- sat result: vector/set of literals (pos 0: satisfiable or not?)
	- solve-dimacs
	- solve-formula
- UNIT TESTS!

- (and p (or p q) r) 		-> creates 4 tseitin symbols for literals
  (or p (and (not p) q))) 	-> solver -> result p: false, q: false
  check tseitin transformation!
  
- tseitin transformation: subs inconsistent, subformulas not needed - only substitutions for literals
- dimacs: remove tautologies (clauses - resolution.clj)
- conjunct generation of clauses (dimacs - resolution); constructor for clauses
- (transform-cnf '(or p q)) 	=> (and (or p q)); not in generate-dimacs
  (transform-cnf '(and a b c)) 	=> (and (or a) (or b) (or c))
- (and) = true
  (and (or)) = false/nil
  -> abort trivial, generate no dimacs, etc.

- SAT4J wrapper
- visualize formula tree graphically (instaparse/visualize) 
- comparison project to: core.logic, kodkod (alloy) (e.g. Sudoku)
- resolution (alternative to sat solving)
- natural deduction

QUESTIONS

NOTES

- MPA: mpf-files - logic samples (use macro processor and recode in clojure)
	Logelei 2
	Sudoku
	Coloring
- SAT solve competitions (www.satcompetitions.org)
- Is it a good idea to remove tautologies from cnf? Yes.
- Printing a truth table is reasonable only for a number of vars up to 12, limiting to 10
- David Nolen, 'Architecture of core.logic'
- only 'and' and 'or' are n-ary, all other operators binary
- Basicfunctions must not be changed from macros to functions as cnf transformation
  would not work anymore (works with macroexpand).
- RSyntaxRichTextArea
- MPA: no own macro processor
  idea: 
    Input "human" code 
    -> Clj-Button 
    -> show clojure code
    -> start REPL (autoload generated code) 
    -> do something...
    -> save (in REPL)
- Queens problem for (n = 2) (must be false for all):
	(a1 -> (!b1 and !a2 and !b2))
	and 
	(a2 -> (!b1 and !b2 and !a1))
	and
	(b1 -> (!a1 and !a2 and !b2))
	and
	(b2 -> (!a1 and !a2 and !b1))
	and
	(a1 or b1)
	and
	(a2 or b2)
	and
	(a1 or a2)
	and
	(b1 or b2)
