/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. D:/usr/br/workspace/mpa/src/mpa/cst/parser/MpaParser.jj */
/*@egen*//** --------------------------------------------------------------------------
 * Grammar for Propositions
 * @author Matthias Peter
 * 
 * Copyright (c) 2007 
 * by Fachhochschule Gie\u00dfen-Friedberg University of Applied Sciences.
 * 
 * mpa is free software; you can redistribute it and/or modify it under 
 * the terms of the GNU General Public License as published by the Free 
 * Software Foundation; either version 2 of the License, or (at your option) 
 * any later version.
 *  
 * mpa is distributed in the hope that it will be useful, but WITHOUT 
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
 * more details. 
 * 
 * You should have received a copy of the GNU General Public License along 
 * with this program; if not, write to the Free Software Foundation, Inc., 
 * 51 Franklin St, Fifth Floor, Boston, MA 02110, USA
 * --------------------------------------------------------------------------
 * $Id:MpaParser.jjt 112 2007-02-06 09:59:22Z br $
 * --------------------------------------------------------------------------
 */

options {                                                                
  STATIC		= true;
}

PARSER_BEGIN(MpaParser)

package mpa.cst.parser;

public class MpaParser/*@bgen(jjtree)*/implements MpaParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTMpaParserState jjtree = new JJTMpaParserState();

/*@egen*/
}

PARSER_END(MpaParser)

SKIP : /* ignore white spaces and comments */
{
    " "
  | "\t"
  | "\n"
  | "\r"
  | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
  | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}



TOKEN : 	
{
    < LPAREN: "(" >
  | < RPAREN: ")" >
  | < LBRACKET: "[" >
  | < RBRACKET: "]" >
}

TOKEN :		/* Constants */
{
	  < TRUE: "T" | "1" | "True" >
	| < FALSE : "F" | "0" | "False" >
}

TOKEN : 	/* Unary operators */
{
 	< NOT: "!" | "not" >
}

/**
 * Precedence of binary operators
 *
 * prec operator     assoc
 * high AND, NAND    left
 *      OR, NOR      left
 *      IF, NIF      right
 *      IMPL, NIMPL  right
 * low  IFF, XOR     left
 */
 
TOKEN :		/* Binary operators */
{
	  < AND:   "&"	 | "and"   >
	| < NAND:  "!&"  | "nand"  >
	| < OR:	   "|"   | "or"    >
	| < NOR:   "!|"  | "nor"   >
	| < IF:	   "<-"  | "if"    >
	| < NIF:           "nif"   >
	| < IMPL:  "->"  | "impl"  >
	| < NIMPL:         "nimpl" >
	| < IFF:   "<->" | "iff"   >
	| < XOR:   "^"   | "xor"   >
}

TOKEN : 
{
      < ATOM: (<LETTER>|<SPECIAL>) (<LETTER>|<SPECIAL>|<DIGIT>)* >
    | < #LETTER:  ["a"-"z", "\u00e4", "\u00f6", "\u00fc", "\u00df", "A"-"Z", "\u00c4", "\u00d6", "\u00dc"] >
    | < #SPECIAL: ["_", "{", "}", ".", "\\"] >
    | < #DIGIT:   ["0"-"9"] >
}


MpaStart Start() : 
{/*@bgen(jjtree) Start */
  MpaStart jjtn000 = new MpaStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
        try {
/*@egen*/
	IffExpr() <EOF>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ { return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void IffExpr()       : /* left assoc */
{ 
	Token t; 
}
{/*@bgen(jjtree) #IffExpr(> 1) */
                {
                  MpaIffExpr jjtn001 = new MpaIffExpr(JJTIFFEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/
		ImplExpr()/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                  }
                }
/*@egen*/
	( ( t = <IFF> | t = <XOR> ) 
			ImplExpr()/*@bgen(jjtree) #IffExpr( 2) */
                                   {
                                     MpaIffExpr jjtn002 = new MpaIffExpr(JJTIFFEXPR);
                                     boolean jjtc002 = true;
                                     jjtree.openNodeScope(jjtn002);
                                   }
                                   try {
/*@egen*//*@bgen(jjtree)*/
                                   {
                                     jjtree.closeNodeScope(jjtn002,  2);
                                     jjtc002 = false;
                                   }
/*@egen*/ { jjtn002.setOp( t.kind );	}/*@bgen(jjtree)*/
                                   } finally {
                                     if (jjtc002) {
                                       jjtree.closeNodeScope(jjtn002,  2);
                                     }
                                   }
/*@egen*/ )* 
}

/* 
 * TODO: improve parser
 * Don't know how to avoid unnecessary intermediate nodes
 * in right associative productions
 */
void ImplExpr() : /* right assoc */
{/*@bgen(jjtree) ImplExpr */
        MpaImplExpr jjtn000 = new MpaImplExpr(JJTIMPLEXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) ImplExpr */
                try {
/*@egen*/
		IfExpr() 
	( ( t = <IMPL> | t = <NIMPL> )  
			ImplExpr() { jjtn000.setOp( t.kind );	} )?/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void IfExpr() : /* right assoc */
{/*@bgen(jjtree) IfExpr */
        MpaIfExpr jjtn000 = new MpaIfExpr(JJTIFEXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) IfExpr */
                try {
/*@egen*/
		OrExpr() 
	( ( t = <IF> | t = <NIF> )
		 	IfExpr() { jjtn000.setOp( t.kind ); } )?/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/	
}

void OrExpr()       :	/* left assoc */
{
	Token t;
}
{/*@bgen(jjtree) #OrExpr(> 1) */
                {
                  MpaOrExpr jjtn001 = new MpaOrExpr(JJTOREXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/
		AndExpr()/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                  }
                }
/*@egen*/
	( ( t = <OR> | t = <NOR> ) 
			AndExpr()/*@bgen(jjtree) #OrExpr( 2) */
                                  {
                                    MpaOrExpr jjtn002 = new MpaOrExpr(JJTOREXPR);
                                    boolean jjtc002 = true;
                                    jjtree.openNodeScope(jjtn002);
                                  }
                                  try {
/*@egen*//*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn002,  2);
                                    jjtc002 = false;
                                  }
/*@egen*/ {	jjtn002.setOp( t.kind ); }/*@bgen(jjtree)*/
                                  } finally {
                                    if (jjtc002) {
                                      jjtree.closeNodeScope(jjtn002,  2);
                                    }
                                  }
/*@egen*/ )*
}

void AndExpr()       :	/* left assoc */
{
	Token t;
}
{/*@bgen(jjtree) #AndExpr(> 1) */
                {
                  MpaAndExpr jjtn001 = new MpaAndExpr(JJTANDEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/
		UnExpr()/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                  }
                }
/*@egen*/
	( ( t = <AND> | t = <NAND> ) 
			UnExpr()/*@bgen(jjtree) #AndExpr( 2) */
                                 {
                                   MpaAndExpr jjtn002 = new MpaAndExpr(JJTANDEXPR);
                                   boolean jjtc002 = true;
                                   jjtree.openNodeScope(jjtn002);
                                 }
                                 try {
/*@egen*//*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn002,  2);
                                   jjtc002 = false;
                                 }
/*@egen*/ { jjtn002.setOp( t.kind ); }/*@bgen(jjtree)*/
                                 } finally {
                                   if (jjtc002) {
                                     jjtree.closeNodeScope(jjtn002,  2);
                                   }
                                 }
/*@egen*/ )*
}

void UnExpr()       :
{}
{
		NotExpr()
	| SubExpr ()
}

void NotExpr() :
{/*@bgen(jjtree) NotExpr */
  MpaNotExpr jjtn000 = new MpaNotExpr(JJTNOTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NotExpr */
                try {
/*@egen*/		<NOT> UnExpr()/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/ {
			jjtn000.setOp( NOT );
		}/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void SubExpr() :
{/*@bgen(jjtree) SubExpr */
  MpaSubExpr jjtn000 = new MpaSubExpr(JJTSUBEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SubExpr */
         try {
/*@egen*/
	 Atom()
	| <TRUE>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/  { jjtn000.setLexeme( "TRUE" ); } 
	| <FALSE>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ { jjtn000.setLexeme( "FALSE" ); }
	| <LPAREN> IffExpr() <RPAREN>/*@bgen(jjtree)*/
                                      {
                                        jjtree.closeNodeScope(jjtn000, true);
                                        jjtc000 = false;
                                      }
/*@egen*/ { jjtn000.setLexeme( "PAREN" ); }
	| <LBRACKET> IffExpr() <RBRACKET>/*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn000, true);
                                            jjtc000 = false;
                                          }
/*@egen*/ { jjtn000.setLexeme( "PAREN" ); }/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}

void Atom() :
{/*@bgen(jjtree) Atom */
        MpaAtom jjtn000 = new MpaAtom(JJTATOM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) Atom */
        try {
/*@egen*/
	t = <ATOM>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ { jjtn000.setLexeme( t.image ); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

