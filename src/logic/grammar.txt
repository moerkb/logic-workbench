(* entry point *)
<S> = expr

(* literals *)
atom			= <spc> ((letter|special) (letter|special|digit)*) <spc>
<letter>		= #"[A-Za-zÄÖÜäöü]"
<special> 		= #"[\_\{\}\.\\]"	(* _ { } . \ *)
<digit> 		= #"[0-9]"
<spc>			= #"\s*"				  

(* token *)
XOR 			= <spc> ("xor"|"^") <spc>
EQUIV 			= <spc> ("iff"|"<->") <spc>
NIMPL 			= <spc> ("nimpl"|"!->") <spc>
IMPL 			= <spc> ("impl"|"->") <spc>
NIF 			= <spc> ("nif"|"!<-") <spc>
IF  			= <spc> ("if"|"<-") <spc>
NOR 			= <spc> ("nor"|"!|") <spc>
OR	 			= <spc> ("or"|"|") <spc>
NAND 			= <spc> ("nand"|"!&") <spc>
AND 			= <spc> ("and"|"&") <spc>
NOT				= <spc> ("not"|"!") <spc>

LPAREN			= <spc> "(" <spc>
RPAREN			= <spc> ")" <spc>
LBRACK			= <spc> "[" <spc>
RBRACK			= <spc> "]" <spc>

(* constants *)     
<constant> 		= <spc> (true|false) <spc>
true 			= <("True"|"true"|"T"|"t"|"1")>  
false 			= <("False"|"false"|"F"|"f"|"0")>

(* unary operators *)
not				= <NOT> unexpr

(* binary operators *)
(* precedence, ascending order
		OP			ASSOC	
		equiv, xor	left
		impl, nimpl	right
		if, nif		right
		or, nor		left
		and, nand	left
*)

<expr>			= equiv_xor

<equiv_xor>		= xor | equiv | impl_nimpl
equiv			= equiv_xor <EQUIV> impl_nimpl 
xor 			= equiv_xor <XOR> impl_nimpl 

<impl_nimpl>	= nimpl | impl | if_nif
impl			= if_nif <IMPL> impl_nimpl
nimpl			= if_nif <NIMPL> impl_nimpl

<if_nif>		= if | nif | or_nor
if				= or_nor <IF> if_nif
nif				= or_nor <NIF> if_nif

<or_nor>		= or | nor | and_nand
or				= or_nor <OR> and_nand
nor				= or_nor <NOR> and_nand

<and_nand>		= and | nand | unexpr
and				= and_nand <AND> unexpr
nand			= and_nand <NAND> unexpr

<unexpr>		= not | subexpr

<subexpr>		= constant / atom /
				  <LPAREN> expr <RPAREN> /
				  <LBRACK> expr <RBRACK>
