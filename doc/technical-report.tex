\documentclass[ngerman,a4paper,abstracton,open=right,twoside=false,toc=listofnumbered,bibtotocnumbered]{scrreprt}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\geometry{a4paper, top=20mm, bottom=40mm, left=40mm, right=25mm, footskip=20mm}

\title{Leistungsvergleich von Clojure--Parsern}
\subtitle{Technischer Bericht zum Masterprojekt\
Technische Hochschule Mittelhessen}
\author{Daniel Kirsten, Markus Bader}
\date{\today}
\begin{document}
\lstset{
	language=Lisp,
	breaklines=true}

\maketitle
\newpage
\begin{abstract}

Im Rahmen des Masterprojekts im Wintersemester 2013/2014 haben die Autoren ein Programm zum Anwenden von Logikfunktionen (z. B. Wahrheitstafeln, Tseitin--Transformation, SAT--Solving) entworfen und mittels der Programmiersprache Clojure implementiert. Unter anderem wird ein Parser zum Umwandeln von logischen Formeln in eine Clojure--Datenstruktur benötigt.

Zu diesem Zweck wurde ein Parser mittels der Bilbiothek Instaparse erzeugt, jedoch viel dessen signifkant längere Laufzeit gegenüber einem JavaCC--Vergleichsparser auf.

In diesem technischen Bericht, welcher zugleich die Abschlussdokumentation zum Projekt darstellt, werden die Laufzeiten von fünf Parsern verglichen: Instaparse und Kern, jeweils mit einer vollständigen und einer minimierten Grammatik, sowie der JavaCC--Referenzparser.

\end{abstract}
\newpage
\tableofcontents
\newpage

\chapter{Einführung}

Bevor auf die eigentlichen Messungen eingegangen wird, sollen zunächst diverse Hintergrundinformationen zu dem Projekt sowie den Parser--Bibliotheken gegeben werden.

\section{MPA}

Der \emph{MNI Proposition Analyzer (MPA)} ist ein im Institut für Softwarearchitektur (ISA) des Fachbereichs Mathematik, Naturwissenschaften und Informatik (MNI) an der Technischen Hochschule Mittelhessen (THM) entwickeltes Programm, um übliche Berechnungen im Bereich der Aussagenlogik anzuwenden. \cite{mpa}

Zu den Features gehören u. a.:

\begin{itemize}
	\item Parsen von Formeln
	\item Ausgeben einer Wahrheitstabelle
	\item Produktion der konjunktiven und disjunktiven Normalform (CNF, DNF)
	\item Anwenden der Tseitin--Transformation
	\item Überprüfen der Erfüllbarkeit einer Formel mittels eines externen SAT--Solver (z. B. SAT4J)
	\item Pretty--print--Funktionen z. B. für Tex.
	\item Anwenden eines externen, M4--kompatiblen Makroprozessors
\end{itemize}

Die Funktionen können über Kommandozeile oder eine GUI angesprochen werden. Das Programm wird in der Lehre an der THM eingesetzt und ist unter der GPL quelloffen verfügbar.

\section{Logical Workbench}

Innerhalb des Masterprojektes der Autoren unter Leitung des bereits für den MPA verantwortlichen Prof. Dr. B. Renz wird ein Programm mit identischen oder ähnlichen Funktionen des MPA entwickelt. Unter dem Projektnamen \emph{Logical Workbench (LW)} wird im Gegensatz zu Java jedoch die Programmiersprache \emph{Clojure} verwendet.

Clojure ist ein LISP, welches zu Java--Bytecode kompiliert und somit auf der JVM arbeitet. Als Besonderheit ist die einfache Verwendung von Java--Code (etwa Klassen) zu nennen, wodurch auch ein von JavaCC generierter Parser--Code benutzt werden kann (siehe Abschnitt \ref{JavaCC}).

Zum Zeitpunkt des Verfassens dieses Textes sind die Kernfunktionen implementiert; im Einzelnen:

\begin{itemize}
	\item Parsen von Formeln
	\item Ausgeben einer Wahrheitstabelle
	\item Produktion der CNF (mittels trivialem Algorithmus oder Tseitin--Transformation)
	\item Generieren des Dimacs--Formats und Aufrufen von SAT4J
\end{itemize}

Ein Makroprozessor wurde nicht eingebunden, da Clojure selbst über ein mächtiges Makrosystem verfügt. Im weiteren Verlauf des Projektes sind die Implementierung einer dem MPA ähnlichen GUI und ein System zum Anwenden der natürlichen Deduktion geplant. Der Code des Projektes ist unter \cite{lw} einsehbar.

\section{Das Problem: Parser--Laufzeiten}

Zu der wesentlichen Kernfunktionalität der LW gehört das Parsen von Formeln, so dass eine Clojure--Liste entsteht, also beispielsweise der String \glqq\lstinline|A -> !(A & B)|\grqq zu \lstinline|(impl A (not (and A B)))| geparst wird. Die vollständige Referenzgrammatik des MPA findet sich in Anhang \ref{refgrammatik}.

Zunächst wurde zur allgemeinen Zufriedenheit die Bibliothek \emph{Instaparse} verwendet. Bei einem Test mit einer großen Formel (Sudoku--Regeln) wurde jedoch eine im Vergleich mit dem Referenzparser sehr viel höhere Laufzeit festgestellt, wenn der mit Instaparse generierte Parser nicht vorher durch einen Stackoverflow abgebrochen wurde. So brauchte dieser in einem Testdurchlauf mehrere Minuten, wogegen der Referenzparser des MPA diese Aufgabe in etwa zwei Sekunden vollbrachte.

Aus diesem Grunde wurden zunächst die Ursachen für die stark wachsende Laufzeit des Instaparse--Parsers eruiert und anschließend eine Vergleichsmessung zwischen verschiedenen Parsern und Grammatiken durchgeführt.

\section{Die Parser--Bibliotheken}

In diesem Abschnitt sollen die für den Vergleich benutzten Parser--Bibliotheken nicht nur vorgesellt werden, auch ihre Anwendung, Konzepte und Eigenheiten werden in Kürze umrissen.

\subsection{Instaparse}

Die von Mark Engelberg entwickelte Bibliothek \emph{Instaparse} gehört zur Gruppe der Parser--Generatoren, d. h. es wird eine Grammatik angegeben, aus der dann ein Programm generiert wird, welches eine Zeichenkette gemäß der Grammatik parsen kann. Da ein Clojure--Programm zur Laufzeit übersetzt werden kann, ist zur Verwendung des generierten Programms kein weiterer Kompilier--Zwischenschritt notwendig, wie etwa bei JavaCC. \cite{instaparse}

Instaparse ist komplett in Clojure geschrieben und wurde deswegen und aufgrund der Simplizität zunächst als Parser für die LW gewählt. So sehen die Schritte zur Entwicklung eines Parsers beispielhaft so aus:

\begin{enumerate}
	\item In einem Clojure--String oder einer externen Text--Datei wird eine Grammatik spezifiziert.
	\item Diese Grammatik wird als Argument einer Funktion \glqq parse\grqq verwendet, welche den Parser zurückgibt, z. B. \lstinline|(def logic-parser (insta/parser ``src/logic/grammar.txt''))|.
	\item Mit diesem Parser kann ein String geparst werden, z. B. erzeugt \lstinline|(logic-parser ``A & B'')| einen abstrakten Syntaxbaum (AST) \lstinline|[:and [:atom ``A''] [:atom ``B'']]|. Als Ausgabeformat stehen dabei hiccup oder enlive zur Verfügung.
	\item Die Funktion \glqq transform\grqq nimmt einen AST und eine Hash--Map zur Substitution an und kann den Parsebaum somit umwandeln. Aus obigem AST wird somit etwa \lstinline|(and A B)|.
\end{enumerate}

\subsection{Kern}

Im Gegensatz zu JavaCC und Instaparse gehören mit \emph{Kern} geschriebene Parser zur Gruppe der Combinator--Parser. Dabei gibt es mehrere \glqq kleine\grqq Parser, also z. B. einen, der eine Konjunktion parst, und einen, der ein Atom parsen kann. Diese Einzelparser können dann mit sogenannten Kombinatoren miteinander verbunden werden, um einen größeren Parser zu erzeugen. Kern bietet eine Reihe von Funktionen, Makros und Datenstrukturen, um solche Combinator--Parser zu erzeugen, z.B. ChainL--Funktionen.

Im Gegensatz zu Instaparse verfügt es dabei über einen dedizierten Lexer, welcher sich nahtlos in die Parsergrammatik einfügt. Dies sorgt einerseits für kompakten Code, kann andererseits aber auch verwirren. So sind \lstinline|token*| und \lstinline|token_| Parser--Funktionen, \lstinline|token| jedoch eine Funktion des Lexers und verlangt einen solchen korrekt eingebunden und eingestellt. Dafür erhöht der Lexer die Komfortabilität, da z. B. die für einen Identifier erlaubten Zeichen als einfacher regulärer Ausdruck angegeben werde können und sich der Benutzer daraufhin nicht mehr um Leerzeichen kümmern muss.

Das Äquivalent zur benötigten Grammatik kann im Sourcecode unter \cite{lw} eingesehen werden. Zu Beachten ist, dass der Autor selber aussagt, dass seine Bibliothek nicht performant ist. 

\begin{quote}
	``Kern's design isn't well-suited for achieving very high performance.'' \cite{kern}
\end{quote}

\subsection{JavaCC}\label{JavaCC}

Wie Instaparse gehört \emph{JavaCC} zur Gruppe der Parser--Generatoren. Es ist jedoch eine Java--Bibliothek und schon weitaus länger in Entwicklung, so dass es ausgereifter ist. \cite{javacc}

JavaCC verlangt eine Grammatik, in der nicht nur die Parseregeln, sondern auch die Regeln des zu produzierenden Codes festgelegt werden können. Daraus erzeugt JavaCC dann Java--Code, der kompiliert dann als Parser verwendet werden kann. Da Clojure die Möglichkeit bietet, Java--Code direkt zu verwenden, kann der Quellcode des MPA übernommen werden; es muss jedoch eine andere Ausgabe erzeugt werden. So besteht im MPA der AST aus verschiedenen Klassen des Types \glqq Knoten\grqq (Node) und kann unter Einsatz eines Visitor--Patterns transformiert werden. Um die in der LW verwendeten Clojure--Listen zu produzieren, wird mittels einer Funktion rekursiv durch den AST traversiert und die neue Struktur aus den Java--Klassen erzeugt.

Die Bibliothek stellt ebenfalls einen Lexer bereit, jedoch kann dieser nicht optional verwendet werden, sondern es müssen alle Token durch diesen erkannt und an den Parser weitergegeben werden können. JavaCC wird produktiv eingesetzt.

\chapter{Versuchsaufbau}

Da wie bereits erwähnt der zuerst implementierte Instaparse--Parser bei einem Beispiel nicht mehr verwendbar war, kam die Idee auf, verschiedene Parser zu vergleichen. Neben besagtem Instaparse und der JavaCC--Referenzimplementierung sollte noch ein Parser verglichen werden, der nach einem gänzlich anderem Prinzip arbeitet. Die Wahl fiel auf Kern.

Um die Ergebnisse der Laufzeitmessung vergleichbar und möglichst aussagekräftig zu halten, müssen die Rahmenbedingungen definiert werden. Dazu gehört die Auswahl der Formeln --- nach quantitativem und qualitativem Umfang, sowie eine bestimmte Reduktion der Grammatiken, um den Laufzeitunterschied mit einem Anwachsen der Parse--Regeln beurteilen zu können.

\section{Allgemeine Aspekte}

Die Messung wird mit der Methode \glqq time\grqq gemessen. Es zählt der Aufruf des Parsers und ggf. das Anwenden einer Transformationsfunktion (um aus einem AST Clojure--Listen zu machen), d. h. es wird immer mit der zu parsenden Formel aufgerufen und es wird letztendlich die Clojure--Datenstruktur durchgelaufen. Innerhalb der Zeitmessung wird nichts auf der Konsole ausgegeben (dies kann zusätzliche Zeit in Anspruch nehmen), noch sind sonstige Seiteneffekte zugelassen.

Sofern möglich, wird jeder Formel mit jedem Parser und jeder der für ihn definierten Grammatiken aufgerufen. Ist dies in einem besonderen Fall nicht möglich, so kann ein errechneter Wert angegeben werden, insofern er als solcher markiert wird. Jeder so mögliche Durchlauf wird zehn Mal durchgeführt und aus allen Ergebnissen das arithmetische Mittel gebildet.

Da einige Parser ihren Zustand des letzten Aufrufes speichern können, ist bei mehreren gleichen Aufrufen hintereinander der erste Aufruf signifikant langsamer als die anderen. Aus diesem Grunde dürfen mit jeweils einem Parser keine zwei identischen Aufrufe direkt aufeinanderfolgend ausgeführt werden.

\section{Grammatiken}

Als Referenz der zu enthaltenden Regeln dient die Parse--Grammatik des MPA (siehe Anhang \ref{refgrammatik}). Es wurden ähnliche Definitionen für Instaparse und Kern vorgenommen und sie produzieren zumindest für die Testformeln das gleiche Ergebnis. Diese Grammatiken werden im Folgenden \emph{volle Grammatiken} genannt.

Um jedoch das Wachstum der Laufzeit durch Hinzufügen von weiteren Regeln messen zu können, wurde für Kern und Instaparse jeweils eine weitere Grammatik definiert. Diese kann nur Formeln verarbeiten, welche enhalten:

\begin{itemize}
	\item Binäroperatoren \glqq and\grqq und \glqq or\grqq durch die Zeichen \glqq \&\grqq bzw. \glqq |\grqq
	\item Unäroperator \glqq not\grqq durch das Zeichen \glqq !\grqq
	\item Klammerung mit runden Klammern
	\item Atome, beginnend mit Unterstrich oder Kleinbuchstaben, fortführend mit Unterstrich, Kleinbuchstaben oder ganze Zahlen
\end{itemize}

Leerzeichen sind dabei nicht erlaubt. Diese Art von Grammatiken wird ab jetzt \emph{minimale Grammatik} genannt.

\section{Formeln}
\section{Messungen}

\chapter{Bewertung}
\section{Instaparse--Wachstum}

\appendix

\begin{thebibliography}{7}
	\bibitem[LW]{lw}
		Quellcode des Projektes auf Github, 
		\url{https://github.com/moerkb/logical-workbench}

	\bibitem[KERN]{kern}
		Armando Blancas,
		Projektseite der Bibliothek Kern, 
		\url{https://github.com/blancas/kern}

	\bibitem[INSTA]{instaparse}
		Mark Engelberg,
		Projektseite der Bibliothek Instaparse,
		\url{https://github.com/Engelberg/instaparse}

	\bibitem[JAVACC]{javacc}
		Java Compiler Compiler,
		\url{https://javacc.java.net}

	\bibitem[MPA]{mpa}
		Prof. Dr. B. Renz,
		Projektseite des MPA,
		\url{http://homepages.thm.de/~hg11260/mpa.html}
\end{thebibliography}

\listoffigures % Abbildungsverzeichnis
\listoftables

\chapter{Sonstiges}
\section{Messergebnisse}
\begin{table}[!h]
	\resizebox{!}{\textwidth}{
		\rotatebox{90}{
			\begin{tabular}{|l|r|r|r|r|r|r|r|r|r|r|r|}
				\hline
				\textbf{USA} & \multicolumn{1}{l|}{\textbf{}} & \multicolumn{1}{l|}{\textbf{}} & \multicolumn{1}{l|}{\textbf{}} & \multicolumn{1}{l|}{\textbf{}} & \multicolumn{1}{l|}{\textbf{}} & \multicolumn{1}{l|}{\textbf{}} & \multicolumn{1}{l|}{\textbf{}} & \multicolumn{1}{l|}{\textbf{}} & \multicolumn{1}{l|}{\textbf{}} & \multicolumn{1}{l|}{\textbf{}} & \textbf{Mittel} \\ \hline
				javacc  & 208 & 217 & 206 & 196 & 179 & 205 & 210 & 212 & 197 & 215 & 204 \\ \hline
				kern, minimal   & 610 & 814 & 832 & 859 & 618 & 593 & 596 & 791 & 851 & 613 & 718 \\ \hline
				kern, voll   & 673 & 665 & 670 & 719 & 658 & 639 & 673 & 660 & 627 & 652 & 664 \\ \hline
				instaparse, minimal   & 595 & 593 & 584 & 607 & 998 & 590 & 553 & 609 & 572 & 592 & 629 \\ \hline
				instaparse, voll   & 4094 & 3652 & 3649 & 3607 & 3798 & 4386 & 4141 & 3759 & 3769 & 4040 & 3890 \\ \hline
				\textbf{4 Damen} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} \\ \hline
				javacc  & 10 & 9 & 10 & 8 & 7 & 15 & 11 & 9 & 15 & 10 & 10 \\ \hline
				kern, voll   & 199 & 199 & 191 & 190 & 187 & 186 & 54 & 194 & 201 & 196 & 180 \\ \hline
				instaparse, minimal   & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & (38) \\ \hline
				instaparse, voll   & 118 & 110 & 107 & 110 & 108 & 121 & 108 & 109 & 112 & 108 & 111 \\ \hline
				\textbf{8 Damen} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} \\ \hline
				javacc  & 92 & 94 & 94 & 72 & 90 & 104 & 93 & 98 & 88 & 109 & 93 \\ \hline
				kern, minimal   & 285 & 276 & 292 & 296 & 275 & 279 & 371 & 286 & 287 & 287 & 293 \\ \hline
				kern, voll   & 645 & 624 & 567 & 649 & 570 & 563 & 468 & 551 & 638 & 626 & 590 \\ \hline
				instaparse, minimal   & 298 & 369 & 345 & 291 & 366 & 376 & 348 & 355 & 368 & 419 & 354 \\ \hline
				instaparse, voll   & 2351 & 2223 & 2249 & 2277 & 2330 & 2306 & 2730 & 2328 & 2238 & 1975 & 2301 \\ \hline
				\textbf{Viertel Sudoku} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} \\ \hline
				javacc  & 629 & 379 & 393 & 375 & 380 & 375 & 659 & 651 & 383 & 384 & 461 \\ \hline
				kern, minimal   & 1274 & 1290 & 1251 & 1292 & 1245 & 1262 & 1345 & 1289 & 1287 & 1283 & 1282 \\ \hline
				kern, voll   & 1720 & 1686 & 1676 & 1792 & 1617 & 1714 & 1707 & 1710 & 1745 & 1670 & 1704 \\ \hline
				instaparse, minimal   & 2102 & 2434 & 3939 & 2322 & 3655 & 2566 & 2096 & 2017 & 3506 & 3686 & 2832 \\ \hline
				instaparse, voll   & 31108 & 28401 & 21306 & 21629 & 21233 & 20991 & 28230 & 28365 & 29472 & 24725 & 25546 \\ \hline
				\textbf{Halbes Sudoku} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} \\ \hline
				javacc  & 472 & 483 & 580 & 489 & 626 & 552 & 419 & 570 & 443 & 609 & 524 \\ \hline
				kern, minimal   & 1657 & 1606 & 1628 & 1714 & 1646 & 1616 & 1706 & 1659 & 1604 & 1591 & 1643 \\ \hline
				kern, voll   & 3580 & 3473 & 3557 & 3741 & 3589 & 3484 & 3735 & 3651 & 3513 & 3535 & 3586 \\ \hline
				instaparse, minimal   & 5151 & 4708 & 5085 & 4941 & 5714 & 4698 & 4196 & 4913 & 5270 & 6938 & 5161 \\ \hline
				instaparse, voll   & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & (63184) \\ \hline
				\textbf{Sudoku} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} \\ \hline
				javacc  & 695 & 1182 & 1028 & 1044 & 1091 & 670 & 720 & 1101 & 1031 & 1067 & 963 \\ \hline
				kern, minimal   & 3051 & 2941 & 3014 & 3198 & 2996 & 2991 & 3141 & 3064 & 2967 & 2982 & 3035 \\ \hline
				kern, voll   & 6977 & 6631 & 6777 & 7279 & 6806 & 6669 & 7165 & 7054 & 6726 & 6852 & 6894 \\ \hline
				instaparse, minimal   & 19072 & 18782 & 18530 & 18439 & 17480 & 19001 & 19870 & 18148 & 18547 & 15740 & 18361 \\ \hline
				instaparse, voll   & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} & (325998) \\ \hline
				\end{tabular}
			}
		}
		\label{Messergebnisse}
		\caption{Ergebnisse der Messreihen, alle Angaben in Millisekunden. Ergebnisse in Klammern sind errechnet.}
\end{table}

\newpage
\section{Referenzgrammatik}\label{refgrammatik}

Das folgende Listing stammt aus der Hilfe--Datei des MPA. \cite{mpa}

\begin{verbatim}	
Proposition	::=	Atom | Const
| "(" UnOp Proposition ")"
| "(" Proposition BinOp Proposition ")"
Atom	::=	([letter]|"_"|"\"|"{"|"}")([letter]|[digit]|"_"|"\"|"{"|"}")*
Const	::=	("T"|"1"|"True"|"F"|"0"|"False")
UnOp	::=	("!"|"not")
BinOp	::=	see Section below
\end{verbatim}

Formeln können mit runden ( (\dots) ) oder eckigen Klammern ( [\dots] ) zusammengefasst werden. Kommentare sind mit (//\dots) zeilenweise oder durch (/*\dots */) blockweise möglich.

Die binären Operatoren \glqq BinOp\grqq sind wie folgt organisiert:

\begin{table}[h!]
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Beschreibung} & \textbf{Syntax} & \textbf{Assoziativität} \\
		\hline
		Und & \&, and & links \\ \hline
		Nicht--Und & !\&, nand & links \\ \hline
		Oder & |, or & links \\ \hline
		Nicht--Oder & !|, nor & links \\ \hline
		Rechtsimplikation & <-, if & rechts \\ \hline
		negierte Rechtsimplikation & nif & rechts \\ \hline
		Implikation & ->, impl & rechts \\ \hline
		negierte Implikation & nimpl & rechts \\ \hline
		Äquivalenz & <->, iff & links \\ \hline
		exklusives Oder & \textasciicircum, xor & links \\ \hline
	\end{tabular}
	\caption{Binäroperatoren mit Syntax und Assoziativität, absteigend sortiert nach Präzedenz}
\end{table}

\end{document}
